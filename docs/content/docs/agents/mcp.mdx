---
title: MCP Server
description: Run and use the SimplePyBLE MCP server.
---

The SimplePyBLE MCP server provides local BLE tools to MCP-capable clients. It is designed for development, debugging, and AI-assisted workflows that need direct access to BLE hardware on the host machine.

## Installation

First, install the package with the `mcp` extra:

```bash
pip install "simplepyble[mcp]"
```

<details open>
<summary><b>Install in Cursor</b></summary>

Go to: `Settings` -> `Cursor Settings` -> `MCP` -> `Add new global MCP server`

Pasting the following configuration into your Cursor `~/.cursor/mcp.json` file is the recommended approach. You may also install in a specific project by creating `.cursor/mcp.json` in your project folder. See [Cursor MCP docs](https://docs.cursor.com/context/model-context-protocol) for more info.

#### Cursor Local Server Connection

[![Install MCP Server](https://cursor.com/deeplink/mcp-install-dark.svg)](https://cursor.com/en/install-mcp?name=simpleble&config=eyJjb21tYW5kIjogInNpbXBsZWFpYmxlIn0=)

```json
{
  "mcpServers": {
    "simpleble": {
      "command": "simpleaible"
    }
  }
}
```

_Note: You must have installed the package first via `pip install "simplepyble[mcp]"`. If `simpleaible` is not in your system PATH, you may need to provide the full path to the executable._

</details>

<details>
<summary><b>Install in Claude Code</b></summary>

Run this command. See [Claude Code MCP docs](https://code.claude.com/docs/en/mcp) for more info.

#### Claude Code Local Server Connection

```sh
claude mcp add simpleble -- simpleaible
```

</details>

<details>
<summary><b>Install in Opencode</b></summary>

Add this to your Opencode configuration file. See [Opencode MCP docs](https://opencode.ai/docs/mcp-servers) for more info.

#### Opencode Local Server Connection

```json
{
  "mcp": {
    "simpleble": {
      "type": "local",
      "command": ["simpleaible"],
      "enabled": true
    }
  }
}
```

</details>

## Tool catalog

All tool inputs/outputs are JSON-serializable. Byte values are returned as hex strings with a best-effort UTF-8 decode.

### `bluetooth_enabled`

Check if Bluetooth is enabled on the host system. Use this tool only when troubleshooting failed operations.

Response:

```json
{ "enabled": true }
```

**Important**: Only call this tool when a BLE operation fails. Assume Bluetooth is enabled by default. Bluetooth must be enabled for all operations to work.

### `get_adapters`

List available Bluetooth adapters.

Response:

```json
[{ "identifier": "Default Adapter [UUID]", "address": "UUID" }]
```

### `scan_for(timeout_ms=5000)`

Scan for nearby BLE devices using the first available adapter.

Response:

```json
[
  {
    "identifier": "DeviceName",
    "address": "UUID-or-MAC",
    "rssi": -55,
    "connectable": true,
    "manufacturer_data": { "76": "0215..." }
  }
]
```

### `connect(address)`

Connect to a device found in the last scan.

Response:

```json
{ "message": "Connected to DeviceName", "address": "UUID-or-MAC" }
```

### `disconnect(address)`

Disconnect from a connected device.

Response:

```json
{ "message": "Disconnected from DeviceName", "address": "UUID-or-MAC" }
```

### `services(address)`

List services and characteristics for a connected device.

Response:

```json
{
  "identifier": "DeviceName",
  "address": "UUID-or-MAC",
  "connected": true,
  "mtu": 23,
  "services": [{ "uuid": "service-uuid", "characteristics": ["char-uuid"] }]
}
```

### `read(address, service_uuid, char_uuid)`

Read a characteristic value.

Response:

```json
{
  "service_uuid": "service-uuid",
  "char_uuid": "char-uuid",
  "data_hex": "00aabb",
  "data_utf8": "..."
}
```

### `write_request(address, service_uuid, char_uuid, data)`

Write data to a characteristic with response. `data` must be a hex string (e.g. `"00aabb"`).

Response:

```json
{ "message": "Write successful" }
```

### `write_command(address, service_uuid, char_uuid, data)`

Write data to a characteristic without response. `data` must be a hex string (e.g. `"00aabb"`).

Response:

```json
{ "message": "Write command successful" }
```

### `notify(address, service_uuid, char_uuid)`

Subscribe to notifications on a characteristic. Data is buffered in the background and can be retrieved with `get_notifications`. Call `unsubscribe` when done.

Response:

```json
{ "message": "Subscribed to notifications" }
```

### `indicate(address, service_uuid, char_uuid)`

Subscribe to indications on a characteristic. Data is buffered in the background and can be retrieved with `get_notifications`. Call `unsubscribe` when done.

Response:

```json
{ "message": "Subscribed to indications" }
```

### `get_notifications(address)`

Retrieve and clear all buffered notifications and indications for a device.

Response:

```json
[
  {
    "service": "service-uuid",
    "characteristic": "char-uuid",
    "data_hex": "163c00",
    "data_utf8": "...",
    "type": "notification"
  }
]
```

### `unsubscribe(address, service_uuid, char_uuid)`

Unsubscribe from notifications or indications on a characteristic.

Response:

```json
{ "message": "Unsubscribed" }
```

## Recommended flow

1. `get_adapters`
2. `scan_for`
3. `connect`
4. `services`
5. `read` for one-time values, or `notify`/`indicate` + `get_notifications` + `unsubscribe` for streaming data
6. `disconnect`

## Platform notes

- On macOS/iOS, device “address” is a UUID, not a MAC address.
- Advertisement fields (RSSI, manufacturer data, service UUIDs) can vary by OS and device.
- Some characteristics require pairing or may be restricted by the OS.

## MCP client example (FastMCP via HTTP)

If you are running the server manually using the HTTP transport (`simpleaible --transport http`), you can connect to it using a FastMCP client:

```python
import asyncio
from fastmcp import Client

async def main():
    # Connect to the server running on the default port 8000
    async with Client("http://127.0.0.1:8000/mcp") as client:
        adapters = await client.call_tool("get_adapters", {})
        # ...
```

Note: FastMCP returns structured results under `structured_content` rather than `data` for some tool outputs.

## Running the server manually

While Cursor handles starting the server automatically, you can also run it manually for testing.

**STDIO Transport (Default):**

```bash
simpleaible
```

**HTTP Transport:**

```bash
simpleaible --transport http --host 127.0.0.1 --port 8000
```
